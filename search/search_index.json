{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"fl\u016bmine Betfair trading framework with a focus on: simplicity modular pythonic rock-solid safe Support for market, order and custom streaming data. join slack group Tested on Python 3.7, 3.8, 3.9 and 3.10. installation $ pip install flumine flumine requires Python 3.7+ setup Get started... import betfairlightweight from flumine import Flumine , clients trading = betfairlightweight . APIClient ( \"username\" ) client = clients . BetfairClient ( trading ) framework = Flumine ( client = client , ) Example strategy: from flumine import BaseStrategy from flumine.order.trade import Trade from flumine.order.order import LimitOrder , OrderStatus from flumine.markets.market import Market from betfairlightweight.filters import streaming_market_filter from betfairlightweight.resources import MarketBook class ExampleStrategy ( BaseStrategy ): def start ( self ) -> None : print ( \"starting strategy 'ExampleStrategy'\" ) def check_market_book ( self , market : Market , market_book : MarketBook ) -> bool : # process_market_book only executed if this returns True if market_book . status != \"CLOSED\" : return True def process_market_book ( self , market : Market , market_book : MarketBook ) -> None : # process marketBook object for runner in market_book . runners : if runner . status == \"ACTIVE\" and runner . last_price_traded < 1.5 : trade = Trade ( market_id = market_book . market_id , selection_id = runner . selection_id , handicap = runner . handicap , strategy = self , ) order = trade . create_order ( side = \"LAY\" , order_type = LimitOrder ( price = 1.01 , size = 2.00 ) ) market . place_order ( order ) def process_orders ( self , market : Market , orders : list ) -> None : for order in orders : if order . status == OrderStatus . EXECUTABLE : if order . size_remaining == 2.00 : market . cancel_order ( order , 0.02 ) # reduce size to 1.98 if order . order_type . persistence_type == \"LAPSE\" : market . update_order ( order , \"PERSIST\" ) if order . size_remaining > 0 : market . replace_order ( order , 1.02 ) # move strategy = ExampleStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ) ) framework . add_strategy ( strategy ) Run framework: framework . run () Danger By default flumine will try to prevent coding errors which result in flash crashes and burnt fingers but use at your own risk as per the MIT license. Recommendation is not to remove the trading controls and carry out extensive testing before executing on live markets, even then only use new strategies on an account with a small balance (transfer balance to games wallet). Features Streaming Multiple strategies Order execution Paper trading Simulation Event simulation (multi market) Middleware and background workers to enable Scores / RaceCard / InPlayService Dependencies flumine relies on these libraries: betfairlightweight - Betfair API support tenacity - Used for connection retrying (streaming) python-json-logger - JSON logging requests - HTTP support","title":"Introduction"},{"location":"#installation","text":"$ pip install flumine flumine requires Python 3.7+","title":"installation"},{"location":"#setup","text":"Get started... import betfairlightweight from flumine import Flumine , clients trading = betfairlightweight . APIClient ( \"username\" ) client = clients . BetfairClient ( trading ) framework = Flumine ( client = client , ) Example strategy: from flumine import BaseStrategy from flumine.order.trade import Trade from flumine.order.order import LimitOrder , OrderStatus from flumine.markets.market import Market from betfairlightweight.filters import streaming_market_filter from betfairlightweight.resources import MarketBook class ExampleStrategy ( BaseStrategy ): def start ( self ) -> None : print ( \"starting strategy 'ExampleStrategy'\" ) def check_market_book ( self , market : Market , market_book : MarketBook ) -> bool : # process_market_book only executed if this returns True if market_book . status != \"CLOSED\" : return True def process_market_book ( self , market : Market , market_book : MarketBook ) -> None : # process marketBook object for runner in market_book . runners : if runner . status == \"ACTIVE\" and runner . last_price_traded < 1.5 : trade = Trade ( market_id = market_book . market_id , selection_id = runner . selection_id , handicap = runner . handicap , strategy = self , ) order = trade . create_order ( side = \"LAY\" , order_type = LimitOrder ( price = 1.01 , size = 2.00 ) ) market . place_order ( order ) def process_orders ( self , market : Market , orders : list ) -> None : for order in orders : if order . status == OrderStatus . EXECUTABLE : if order . size_remaining == 2.00 : market . cancel_order ( order , 0.02 ) # reduce size to 1.98 if order . order_type . persistence_type == \"LAPSE\" : market . update_order ( order , \"PERSIST\" ) if order . size_remaining > 0 : market . replace_order ( order , 1.02 ) # move strategy = ExampleStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ) ) framework . add_strategy ( strategy ) Run framework: framework . run () Danger By default flumine will try to prevent coding errors which result in flash crashes and burnt fingers but use at your own risk as per the MIT license. Recommendation is not to remove the trading controls and carry out extensive testing before executing on live markets, even then only use new strategies on an account with a small balance (transfer balance to games wallet).","title":"setup"},{"location":"#features","text":"Streaming Multiple strategies Order execution Paper trading Simulation Event simulation (multi market) Middleware and background workers to enable Scores / RaceCard / InPlayService","title":"Features"},{"location":"#dependencies","text":"flumine relies on these libraries: betfairlightweight - Betfair API support tenacity - Used for connection retrying (streaming) python-json-logger - JSON logging requests - HTTP support","title":"Dependencies"},{"location":"advanced/","text":"Advanced Flumine Functions: add_client Adds a client to the framework add_strategy Adds a strategy to the framework add_worker Adds a worker to the framework add_client_control Adds a client control to the framework add_trading_control Adds a trading control to the framework add_market_middleware Adds market middleware to the framework add_logging_control Adds a logging control to the framework The Flumine class can be adapted by overriding the following functions: _process_market_books() called on MarketBook event _process_sports_data() called on SportsData event _process_market_orders() called when market has pending orders _process_order_package() called on new OrderPackage _add_market() called when new Market received through streams _remove_market() called when Market removed from framework _process_raw_data() called on RawData event _process_market_catalogues called on MarketCatalogue event _process_current_orders called on currentOrders event _process_custom_event called on CustomEvent event see here _process_close_market called on Market closure _process_cleared_orders() called on ClearedOrders event _process_cleared_markets() called on ClearedMarkets event _process_end_flumine() called on Flumine termination Streams Market Stream Flumine handles market streams by taking the parameters provided in the strategies, a strategy will then subscribe to the stream. This means strategies can share streams reducing load or create new if they require different markets or data filter. Data Stream Similar to Market Streams but the raw streaming data is passed back, this reduces ram/CPU and allows recording of the data for future playback, see the example marketrecorder.py Historical Stream This is created on a per market basis when simulating. Order Stream Subscribes to all orders per running instance using the config.customer_strategy_ref Custom Streams Custom streams (aka threads) can be added as per: from flumine.streams.basestream import BaseStream from flumine.events.events import CustomEvent class CustomStream ( BaseStream ): def run ( self ) -> None : # connect to stream / make API requests etc. response = api_call () # callback func def callback ( framework , event ): for strategy in framework . strategies : strategy . process_my_event ( event ) # push results through using custom event event = CustomEvent ( response , callback ) # put in main queue self . flumine . handler_queue . put ( event ) custom_stream = CustomStream ( framework , custom = True ) framework . streams . add_custom_stream ( custom_stream ) Error Handling Flumine will catch all errors that occur in strategy.check_market and strategy.process_market_book , and log either error or critical errors. Tip You can remove this error handling by setting config.raise_errors = True Logging jsonlogger is used to log extra detail, see below for a typical setup: import time import logging from pythonjsonlogger import jsonlogger logger = logging . getLogger () custom_format = \" %(asctime) % (levelname) %(message)\" log_handler = logging . StreamHandler () formatter = jsonlogger . JsonFormatter ( custom_format ) formatter . converter = time . gmtime log_handler . setFormatter ( formatter ) logger . addHandler ( log_handler ) logger . setLevel ( logging . INFO ) Config simulated Updated to True when simulating or paper trading simulated_strategy_isolation Defaults to True to match orders per strategy, when False prevents double counting of passive liquidity on all orders regardless of strategy. instance_id Store server id or similar (e.g. AWS ec2 instanceId) customer_strategy_ref Used as customerStrategyRefs so that only orders created by the running instance are returned. process_id OS process id of running application. current_time Used for simulation raise_errors Raises errors on strategy functions, see Error Handling max_execution_workers Max number of workers in execution thread pool async_place_orders Place orders sent with place orders flag, prevents waiting for bet delay place_latency Place latency used for simulation / simulation execution cancel_latency Cancel latency used for simulation / simulation execution update_latency Update latency used for simulation / simulation execution replace_latency Replace latency used for simulation / simulation execution order_sep customer_order_ref separator","title":"Advanced Usage"},{"location":"advanced/#advanced","text":"","title":"Advanced"},{"location":"advanced/#flumine","text":"Functions: add_client Adds a client to the framework add_strategy Adds a strategy to the framework add_worker Adds a worker to the framework add_client_control Adds a client control to the framework add_trading_control Adds a trading control to the framework add_market_middleware Adds market middleware to the framework add_logging_control Adds a logging control to the framework The Flumine class can be adapted by overriding the following functions: _process_market_books() called on MarketBook event _process_sports_data() called on SportsData event _process_market_orders() called when market has pending orders _process_order_package() called on new OrderPackage _add_market() called when new Market received through streams _remove_market() called when Market removed from framework _process_raw_data() called on RawData event _process_market_catalogues called on MarketCatalogue event _process_current_orders called on currentOrders event _process_custom_event called on CustomEvent event see here _process_close_market called on Market closure _process_cleared_orders() called on ClearedOrders event _process_cleared_markets() called on ClearedMarkets event _process_end_flumine() called on Flumine termination","title":"Flumine"},{"location":"advanced/#streams","text":"","title":"Streams"},{"location":"advanced/#market-stream","text":"Flumine handles market streams by taking the parameters provided in the strategies, a strategy will then subscribe to the stream. This means strategies can share streams reducing load or create new if they require different markets or data filter.","title":"Market Stream"},{"location":"advanced/#data-stream","text":"Similar to Market Streams but the raw streaming data is passed back, this reduces ram/CPU and allows recording of the data for future playback, see the example marketrecorder.py","title":"Data Stream"},{"location":"advanced/#historical-stream","text":"This is created on a per market basis when simulating.","title":"Historical Stream"},{"location":"advanced/#order-stream","text":"Subscribes to all orders per running instance using the config.customer_strategy_ref","title":"Order Stream"},{"location":"advanced/#custom-streams","text":"Custom streams (aka threads) can be added as per: from flumine.streams.basestream import BaseStream from flumine.events.events import CustomEvent class CustomStream ( BaseStream ): def run ( self ) -> None : # connect to stream / make API requests etc. response = api_call () # callback func def callback ( framework , event ): for strategy in framework . strategies : strategy . process_my_event ( event ) # push results through using custom event event = CustomEvent ( response , callback ) # put in main queue self . flumine . handler_queue . put ( event ) custom_stream = CustomStream ( framework , custom = True ) framework . streams . add_custom_stream ( custom_stream )","title":"Custom Streams"},{"location":"advanced/#error-handling","text":"Flumine will catch all errors that occur in strategy.check_market and strategy.process_market_book , and log either error or critical errors. Tip You can remove this error handling by setting config.raise_errors = True","title":"Error Handling"},{"location":"advanced/#logging","text":"jsonlogger is used to log extra detail, see below for a typical setup: import time import logging from pythonjsonlogger import jsonlogger logger = logging . getLogger () custom_format = \" %(asctime) % (levelname) %(message)\" log_handler = logging . StreamHandler () formatter = jsonlogger . JsonFormatter ( custom_format ) formatter . converter = time . gmtime log_handler . setFormatter ( formatter ) logger . addHandler ( log_handler ) logger . setLevel ( logging . INFO )","title":"Logging"},{"location":"advanced/#config","text":"","title":"Config"},{"location":"advanced/#simulated","text":"Updated to True when simulating or paper trading","title":"simulated"},{"location":"advanced/#simulated_strategy_isolation","text":"Defaults to True to match orders per strategy, when False prevents double counting of passive liquidity on all orders regardless of strategy.","title":"simulated_strategy_isolation"},{"location":"advanced/#instance_id","text":"Store server id or similar (e.g. AWS ec2 instanceId)","title":"instance_id"},{"location":"advanced/#customer_strategy_ref","text":"Used as customerStrategyRefs so that only orders created by the running instance are returned.","title":"customer_strategy_ref"},{"location":"advanced/#process_id","text":"OS process id of running application.","title":"process_id"},{"location":"advanced/#current_time","text":"Used for simulation","title":"current_time"},{"location":"advanced/#raise_errors","text":"Raises errors on strategy functions, see Error Handling","title":"raise_errors"},{"location":"advanced/#max_execution_workers","text":"Max number of workers in execution thread pool","title":"max_execution_workers"},{"location":"advanced/#async_place_orders","text":"Place orders sent with place orders flag, prevents waiting for bet delay","title":"async_place_orders"},{"location":"advanced/#place_latency","text":"Place latency used for simulation / simulation execution","title":"place_latency"},{"location":"advanced/#cancel_latency","text":"Cancel latency used for simulation / simulation execution","title":"cancel_latency"},{"location":"advanced/#update_latency","text":"Update latency used for simulation / simulation execution","title":"update_latency"},{"location":"advanced/#replace_latency","text":"Replace latency used for simulation / simulation execution","title":"replace_latency"},{"location":"advanced/#order_sep","text":"customer_order_ref separator","title":"order_sep"},{"location":"architecture/","text":"Design Main loop Typical to most trading frameworks flumine uses an event driven design with the main thread handling these events through a FIFO queue . handles all events in order one by one runs in main UML Diagrams Packages Classes Events: MARKET_CATALOGUE Betfair MarketCatalogue object MARKET_BOOK Betfair MarketBook object RAW_DATA Raw streaming data CURRENT_ORDERS Betfair CurrentOrders object CLEARED_MARKETS Betfair ClearedMarkets object CLEARED_ORDERS Betfair ClearedOrders object CLOSE_MARKET flumine Close Market update STRATEGY_RESET flumine Strategy Reset update CUSTOM_EVENT flumine Custom event update TERMINATOR flumine End instance update The above events are handled in the flumine class MarketBook Cycle Simulation Simulation is achieved by monkeypatching the datetime function utcnow(), this allows strategies to be simulated as if they were being executed in real time. Functions such as market.seconds_to_start and fillKill.seconds work as per a live execution. Streams Single stream (market) As above but 'data' (flumine listener) Order stream Future work: Custom stream Strategy Class based Subscribe to streams Single strategy subscribes to a single market stream Handles Stream reconnect Trading client login/logout Trading client keep alive Future work: Execution place/cancel/replace/update controls fillKill Market Catalogue Polling (scores/raceCard etc) CurrentOrders / ClearedOrders database connection/logging notes market middleware (analytics/logging) order middleware (controls) paper trading simulation","title":"Architecture"},{"location":"architecture/#design","text":"","title":"Design"},{"location":"architecture/#main-loop","text":"Typical to most trading frameworks flumine uses an event driven design with the main thread handling these events through a FIFO queue . handles all events in order one by one runs in main","title":"Main loop"},{"location":"architecture/#uml-diagrams","text":"","title":"UML Diagrams"},{"location":"architecture/#packages","text":"","title":"Packages"},{"location":"architecture/#classes","text":"","title":"Classes"},{"location":"architecture/#events","text":"MARKET_CATALOGUE Betfair MarketCatalogue object MARKET_BOOK Betfair MarketBook object RAW_DATA Raw streaming data CURRENT_ORDERS Betfair CurrentOrders object CLEARED_MARKETS Betfair ClearedMarkets object CLEARED_ORDERS Betfair ClearedOrders object CLOSE_MARKET flumine Close Market update STRATEGY_RESET flumine Strategy Reset update CUSTOM_EVENT flumine Custom event update TERMINATOR flumine End instance update The above events are handled in the flumine class","title":"Events:"},{"location":"architecture/#marketbook-cycle","text":"","title":"MarketBook Cycle"},{"location":"architecture/#simulation","text":"Simulation is achieved by monkeypatching the datetime function utcnow(), this allows strategies to be simulated as if they were being executed in real time. Functions such as market.seconds_to_start and fillKill.seconds work as per a live execution.","title":"Simulation"},{"location":"architecture/#streams","text":"Single stream (market) As above but 'data' (flumine listener) Order stream Future work: Custom stream","title":"Streams"},{"location":"architecture/#strategy","text":"Class based Subscribe to streams Single strategy subscribes to a single market stream","title":"Strategy"},{"location":"architecture/#handles","text":"Stream reconnect Trading client login/logout Trading client keep alive Future work: Execution place/cancel/replace/update controls fillKill Market Catalogue Polling (scores/raceCard etc) CurrentOrders / ClearedOrders database connection/logging","title":"Handles"},{"location":"architecture/#notes","text":"market middleware (analytics/logging) order middleware (controls) paper trading simulation","title":"notes"},{"location":"clients/","text":"Clients Flumine is capable of using multiple clients, these can be of the same ExchangeType , a variation depending on use case or your own custom client/wrapper. The default workers handle login/keep-alive/logout and market closure for all clients added to the framework automatically. ExchangeTypes BETFAIR: BetfairClient SIMULATED: SimulatedClient BETCONNECT: BetconnectClient Strategy use To add a client use the add_client this will allow use via framework.clients or strategy.clients from flumine import Flumine , clients framework = Flumine () client = clients . BetfairClient ( trading ) framework . add_client ( client ) or when simulating: from flumine import FlumineSimulation , clients framework = FlumineSimulation () client = clients . SimulatedClient ( username = \"123\" ) framework . add_client ( client ) To access clients within a strategy use the helper functions: betfair_client = self . clients . get_betfair_default () client = self . clients . get_client ( ExchangeType . SIMULATED , username = \"123\" ) Tip get_default and get_betfair_default will use the first client added via add_client (ordered list) By default a transaction will use clients.get_default() however you can use a particular client: client = self . clients . get_client ( ExchangeType . SIMULATED , username = \"123\" ) market . place_order ( order , client = client ) or using a transaction directly: client = self . clients . get_client ( ExchangeType . SIMULATED , username = \"123\" ) with market . transaction ( client = client ) as t : t . place_order ( order ) Future Development BetConnect client #566","title":"Clients"},{"location":"clients/#clients","text":"Flumine is capable of using multiple clients, these can be of the same ExchangeType , a variation depending on use case or your own custom client/wrapper. The default workers handle login/keep-alive/logout and market closure for all clients added to the framework automatically.","title":"Clients"},{"location":"clients/#exchangetypes","text":"BETFAIR: BetfairClient SIMULATED: SimulatedClient BETCONNECT: BetconnectClient","title":"ExchangeTypes"},{"location":"clients/#strategy-use","text":"To add a client use the add_client this will allow use via framework.clients or strategy.clients from flumine import Flumine , clients framework = Flumine () client = clients . BetfairClient ( trading ) framework . add_client ( client ) or when simulating: from flumine import FlumineSimulation , clients framework = FlumineSimulation () client = clients . SimulatedClient ( username = \"123\" ) framework . add_client ( client ) To access clients within a strategy use the helper functions: betfair_client = self . clients . get_betfair_default () client = self . clients . get_client ( ExchangeType . SIMULATED , username = \"123\" ) Tip get_default and get_betfair_default will use the first client added via add_client (ordered list) By default a transaction will use clients.get_default() however you can use a particular client: client = self . clients . get_client ( ExchangeType . SIMULATED , username = \"123\" ) market . place_order ( order , client = client ) or using a transaction directly: client = self . clients . get_client ( ExchangeType . SIMULATED , username = \"123\" ) with market . transaction ( client = client ) as t : t . place_order ( order )","title":"Strategy use"},{"location":"clients/#future-development","text":"BetConnect client #566","title":"Future Development"},{"location":"controls/","text":"Controls Trading Controls Before placing an order flumine will check the client and trading controls, this allows validation to occur before execution. If an order does not meet any of these validations it is not executed and status is updated to Violation . Client Controls MaxTransactionCount : Checks transaction count is not over betfair transaction limit (5000 per hour) Trading Controls OrderValidation : Checks order is valid (size/odds) StrategyExposure : Checks order does not invalidate strategy.validate_order , strategy.max_order_exposure or strategy.max_selection_exposure Skipping Controls Sometimes it is desirable to skip the controls, for example when canceling an open order even if the transaction count has already reached the betfair transaction limit. This can be done by passing force=True when placing or changing an order: market . place_order ( order , force = True ) transaction . place_order ( order , force = True ) This works for markets and transactions and is supported by the operations place_order , cancel_order , update_order , and replace_order . Logging Controls Custom logging is available using the LoggingControl class, the base class creates debug logs and can be used as follows: from flumine.controls.loggingcontrols import LoggingControl control = LoggingControl () framework . add_logging_control ( control ) Tip More than one control can be added, for example a csv logger and db logger.","title":"Controls"},{"location":"controls/#controls","text":"","title":"Controls"},{"location":"controls/#trading-controls","text":"Before placing an order flumine will check the client and trading controls, this allows validation to occur before execution. If an order does not meet any of these validations it is not executed and status is updated to Violation .","title":"Trading Controls"},{"location":"controls/#client-controls","text":"MaxTransactionCount : Checks transaction count is not over betfair transaction limit (5000 per hour)","title":"Client Controls"},{"location":"controls/#trading-controls_1","text":"OrderValidation : Checks order is valid (size/odds) StrategyExposure : Checks order does not invalidate strategy.validate_order , strategy.max_order_exposure or strategy.max_selection_exposure","title":"Trading Controls"},{"location":"controls/#skipping-controls","text":"Sometimes it is desirable to skip the controls, for example when canceling an open order even if the transaction count has already reached the betfair transaction limit. This can be done by passing force=True when placing or changing an order: market . place_order ( order , force = True ) transaction . place_order ( order , force = True ) This works for markets and transactions and is supported by the operations place_order , cancel_order , update_order , and replace_order .","title":"Skipping Controls"},{"location":"controls/#logging-controls","text":"Custom logging is available using the LoggingControl class, the base class creates debug logs and can be used as follows: from flumine.controls.loggingcontrols import LoggingControl control = LoggingControl () framework . add_logging_control ( control ) Tip More than one control can be added, for example a csv logger and db logger.","title":"Logging Controls"},{"location":"help/","text":"Help Please try the following channels for any support: Betfair Developer Support Slack Group for any help in using the library API Status if things don't seem to be working","title":"Help"},{"location":"help/#help","text":"Please try the following channels for any support: Betfair Developer Support Slack Group for any help in using the library API Status if things don't seem to be working","title":"Help"},{"location":"markets/","text":"Markets Market Within markets you have market objects which contains current up to date market data. Class variables flumine Framework market_id MarketBook id closed Closed bool date_time_closed Closed datetime market_book Latest MarketBook object market_catalogue Latest MarketCatalogue object context Market context, store market specific context e.g. simulated data store blotter Holds all order data and position Functions place_order(order) Place new order from order object cancel_order(order, size_reduction) Cancel order update_order(order, new_persistance_type) Update order replace_order(order, new_price) Replace order Properties event Dictionary containing all event related markets (assumes markets have been subscribed) event_type_id Betfair event type id (horse racing: 7) event_id Market event id (12345) market_type Market type ('WIN') seconds_to_start Seconds to scheduled market start time (123.45) elapsed_seconds_closed Seconds since market was closed (543.21) market_start_datetime Market scheduled start time Transaction The transaction class is used by default when orders are executed, however it is possible to control the execution behaviour using the transaction class like so: with market . transaction () as t : market . place_order ( order ) # executed immediately in separate transaction t . place_order ( order ) # executed on transaction __exit__ with market . transaction () as t : t . place_order ( order ) .. t . execute () # above order executed .. t . cancel_order ( order ) t . place_order ( order ) # both executed on transaction __exit__ Blotter The blotter is a simple and fast class to hold all orders for a particular market. Functions strategy_orders(strategy) Returns all orders related to a strategy strategy_selection_orders(strategy, selection_id, handicap) Returns all orders related to a strategy selection selection_exposure(strategy, lookup) Returns strategy/selection exposure market_exposure(strategy, market_book) Returns strategy/market exposure Properties live_orders List of live orders has_live_orders Bool on live orders Middleware It is common that you want to carry about analysis on a market before passing through to strategies, similar to Django's middleware design flumine allows middleware to be executed. For example simulation uses simulated middleware in order to calculate order matching. Note Middleware will be executed in the order it is added and before the strategies are processed. Please see below for the example middleware class if you wish to create your own: from flumine.markets.middleware import Middleware class CustomMiddleware ( Middleware ): def __call__ ( self , market ) -> None : pass # called on each MarketBook update def add_market ( self , market ) -> None : print ( \"market {0} added\" . format ( market . market_id )) def remove_market ( self , market ) -> None : print ( \"market {0} removed\" . format ( market . market_id )) The above middleware can then be added to the framework: framework . add_logging_control ( CustomMiddleware ())","title":"Markets"},{"location":"markets/#markets","text":"","title":"Markets"},{"location":"markets/#market","text":"Within markets you have market objects which contains current up to date market data.","title":"Market"},{"location":"markets/#class-variables","text":"flumine Framework market_id MarketBook id closed Closed bool date_time_closed Closed datetime market_book Latest MarketBook object market_catalogue Latest MarketCatalogue object context Market context, store market specific context e.g. simulated data store blotter Holds all order data and position","title":"Class variables"},{"location":"markets/#functions","text":"place_order(order) Place new order from order object cancel_order(order, size_reduction) Cancel order update_order(order, new_persistance_type) Update order replace_order(order, new_price) Replace order","title":"Functions"},{"location":"markets/#properties","text":"event Dictionary containing all event related markets (assumes markets have been subscribed) event_type_id Betfair event type id (horse racing: 7) event_id Market event id (12345) market_type Market type ('WIN') seconds_to_start Seconds to scheduled market start time (123.45) elapsed_seconds_closed Seconds since market was closed (543.21) market_start_datetime Market scheduled start time","title":"Properties"},{"location":"markets/#transaction","text":"The transaction class is used by default when orders are executed, however it is possible to control the execution behaviour using the transaction class like so: with market . transaction () as t : market . place_order ( order ) # executed immediately in separate transaction t . place_order ( order ) # executed on transaction __exit__ with market . transaction () as t : t . place_order ( order ) .. t . execute () # above order executed .. t . cancel_order ( order ) t . place_order ( order ) # both executed on transaction __exit__","title":"Transaction"},{"location":"markets/#blotter","text":"The blotter is a simple and fast class to hold all orders for a particular market.","title":"Blotter"},{"location":"markets/#functions_1","text":"strategy_orders(strategy) Returns all orders related to a strategy strategy_selection_orders(strategy, selection_id, handicap) Returns all orders related to a strategy selection selection_exposure(strategy, lookup) Returns strategy/selection exposure market_exposure(strategy, market_book) Returns strategy/market exposure","title":"Functions"},{"location":"markets/#properties_1","text":"live_orders List of live orders has_live_orders Bool on live orders","title":"Properties"},{"location":"markets/#middleware","text":"It is common that you want to carry about analysis on a market before passing through to strategies, similar to Django's middleware design flumine allows middleware to be executed. For example simulation uses simulated middleware in order to calculate order matching. Note Middleware will be executed in the order it is added and before the strategies are processed. Please see below for the example middleware class if you wish to create your own: from flumine.markets.middleware import Middleware class CustomMiddleware ( Middleware ): def __call__ ( self , market ) -> None : pass # called on each MarketBook update def add_market ( self , market ) -> None : print ( \"market {0} added\" . format ( market . market_id )) def remove_market ( self , market ) -> None : print ( \"market {0} removed\" . format ( market . market_id )) The above middleware can then be added to the framework: framework . add_logging_control ( CustomMiddleware ())","title":"Middleware"},{"location":"performance/","text":"Performance Flumine is heavily optimised out of the box to be as quick as possible however there are various ways to improve the performance further with minimal effort. Simulation Listener Kwargs This is one of the most powerful options available as the variables are passed down to betfairlightweight limiting the number of updates to process, examples: 600s before scheduled start and no inplay strategy = ExampleStrategy ( market_filter = { \"markets\" : [ \"/tmp/marketdata/1.170212754\" ], \"listener_kwargs\" : { \"seconds_to_start\" : 600 , \"inplay\" : False }, } ) inplay only strategy = ExampleStrategy ( market_filter = { \"markets\" : [ \"/tmp/marketdata/1.170212754\" ], \"listener_kwargs\" : { \"inplay\" : True }, } ) Logging Logging in python can add a lot of function calls, it is therefore recommended to switch it off once you are comfortable with the outputs from a strategy: logger . setLevel ( logging . CRITICAL ) File location This might sound obvious but having the market files stored locally on your machine will allow much quicker processing. A common pattern is to use s3 to store all market files but a local cache for common markets processed. smart_open is a commonly used package for processing gz/s3 files: with patch ( \"builtins.open\" , smart_open . open ): framework . add_strategy ( strategy ) framework . run () Tip Note that add_strategy needs to be in the patch as well. Betfair Historical Data Sometimes a download from the betfair site will include market and event files in the same directory resulting in duplicate processing, flumine will log a warning on this but it is worth checking if you are seeing slow processing times. Multiprocessing Simulation is CPU bound so can therefore be improved through the use of multiprocessing, threading offers no improvement due to the limitations of the GIL. The multiprocessing example code below will: run a process per core each run_process will process 8 markets at a time (prevents memory leaks) will wait for all results before completing import os import math import smart_open from concurrent import futures from unittest.mock import patch as mock_patch from flumine import FlumineSimulation , clients , utils from strategies.lowestlayer import LowestLayer def run_process ( markets ): client = clients . SimulatedClient () framework = FlumineSimulation ( client = client ) strategy = LowestLayer ( market_filter = { \"markets\" : markets }, context = { \"stake\" : 2 }, ) with mock_patch ( \"builtins.open\" , smart_open . open ): framework . add_strategy ( strategy ) framework . run () if __name__ == \"__main__\" : all_markets = [ ... ] processes = os . cpu_count () markets_per_process = 8 # optimal _process_jobs = [] with futures . ProcessPoolExecutor ( max_workers = processes ) as p : chunk = min ( markets_per_process , math . ceil ( len ( all_markets ) / processes ) ) for m in ( utils . chunks ( all_markets , chunk )): _process_jobs . append ( p . submit ( run_process , markets = m , ) ) for job in futures . as_completed ( _process_jobs ): job . result () # wait for result Tip If the code above is failing add logging to the run_process function to find the error or run the strategy in a single process with logging Strategy The heaviest load on CPU comes from reading the files and processing into py objects before processing through flumine, after this the bottleneck becomes the number of orders that need to be processed. Therefore anything that can be done to limit the number of redundant or control blocked orders will see an improvement. cprofile Profiling code is always the best option for finding improvements, cprofilev is a commonly used python library for this: python -m cprofilev examples/backtest.py Middleware If you don't need the simulation middleware remove it from framework._market_middleware , this is useful when processing markets for data collection. This can dramatically improve processing time due to the heavy functions contained in the simulation logic. Libraries Installing betfairlightweight[speed] will have a big impact on processing speed due to the inclusion of C and Rust libraries for datetime and json decoding. Live For improving live trading 'Strategy' and 'cprofile' tips above will help although CPU load tends to be considerably lower compared to simulating.","title":"Performance"},{"location":"performance/#performance","text":"Flumine is heavily optimised out of the box to be as quick as possible however there are various ways to improve the performance further with minimal effort.","title":"Performance"},{"location":"performance/#simulation","text":"","title":"Simulation"},{"location":"performance/#listener-kwargs","text":"This is one of the most powerful options available as the variables are passed down to betfairlightweight limiting the number of updates to process, examples:","title":"Listener Kwargs"},{"location":"performance/#600s-before-scheduled-start-and-no-inplay","text":"strategy = ExampleStrategy ( market_filter = { \"markets\" : [ \"/tmp/marketdata/1.170212754\" ], \"listener_kwargs\" : { \"seconds_to_start\" : 600 , \"inplay\" : False }, } )","title":"600s before scheduled start and no inplay"},{"location":"performance/#inplay-only","text":"strategy = ExampleStrategy ( market_filter = { \"markets\" : [ \"/tmp/marketdata/1.170212754\" ], \"listener_kwargs\" : { \"inplay\" : True }, } )","title":"inplay only"},{"location":"performance/#logging","text":"Logging in python can add a lot of function calls, it is therefore recommended to switch it off once you are comfortable with the outputs from a strategy: logger . setLevel ( logging . CRITICAL )","title":"Logging"},{"location":"performance/#file-location","text":"This might sound obvious but having the market files stored locally on your machine will allow much quicker processing. A common pattern is to use s3 to store all market files but a local cache for common markets processed. smart_open is a commonly used package for processing gz/s3 files: with patch ( \"builtins.open\" , smart_open . open ): framework . add_strategy ( strategy ) framework . run () Tip Note that add_strategy needs to be in the patch as well.","title":"File location"},{"location":"performance/#betfair-historical-data","text":"Sometimes a download from the betfair site will include market and event files in the same directory resulting in duplicate processing, flumine will log a warning on this but it is worth checking if you are seeing slow processing times.","title":"Betfair Historical Data"},{"location":"performance/#multiprocessing","text":"Simulation is CPU bound so can therefore be improved through the use of multiprocessing, threading offers no improvement due to the limitations of the GIL. The multiprocessing example code below will: run a process per core each run_process will process 8 markets at a time (prevents memory leaks) will wait for all results before completing import os import math import smart_open from concurrent import futures from unittest.mock import patch as mock_patch from flumine import FlumineSimulation , clients , utils from strategies.lowestlayer import LowestLayer def run_process ( markets ): client = clients . SimulatedClient () framework = FlumineSimulation ( client = client ) strategy = LowestLayer ( market_filter = { \"markets\" : markets }, context = { \"stake\" : 2 }, ) with mock_patch ( \"builtins.open\" , smart_open . open ): framework . add_strategy ( strategy ) framework . run () if __name__ == \"__main__\" : all_markets = [ ... ] processes = os . cpu_count () markets_per_process = 8 # optimal _process_jobs = [] with futures . ProcessPoolExecutor ( max_workers = processes ) as p : chunk = min ( markets_per_process , math . ceil ( len ( all_markets ) / processes ) ) for m in ( utils . chunks ( all_markets , chunk )): _process_jobs . append ( p . submit ( run_process , markets = m , ) ) for job in futures . as_completed ( _process_jobs ): job . result () # wait for result Tip If the code above is failing add logging to the run_process function to find the error or run the strategy in a single process with logging","title":"Multiprocessing"},{"location":"performance/#strategy","text":"The heaviest load on CPU comes from reading the files and processing into py objects before processing through flumine, after this the bottleneck becomes the number of orders that need to be processed. Therefore anything that can be done to limit the number of redundant or control blocked orders will see an improvement.","title":"Strategy"},{"location":"performance/#cprofile","text":"Profiling code is always the best option for finding improvements, cprofilev is a commonly used python library for this: python -m cprofilev examples/backtest.py","title":"cprofile"},{"location":"performance/#middleware","text":"If you don't need the simulation middleware remove it from framework._market_middleware , this is useful when processing markets for data collection. This can dramatically improve processing time due to the heavy functions contained in the simulation logic.","title":"Middleware"},{"location":"performance/#libraries","text":"Installing betfairlightweight[speed] will have a big impact on processing speed due to the inclusion of C and Rust libraries for datetime and json decoding.","title":"Libraries"},{"location":"performance/#live","text":"For improving live trading 'Strategy' and 'cprofile' tips above will help although CPU load tends to be considerably lower compared to simulating.","title":"Live"},{"location":"quickstart/","text":"QuickStart Live Tip flumine uses betfairlightweight for communicating with the Betfair API, please see docs for how to use/setup before proceeding. First, start by importing flumine/bflw and creating a trading and framework client: import betfairlightweight from flumine import Flumine , clients trading = betfairlightweight . APIClient ( \"username\" ) client = clients . BetfairClient ( trading ) framework = Flumine ( client = client ) Note flumine will handle login, logout and keep alive whilst the framework is running using the keep_alive worker. A strategy can now be created by using the BaseStrategy class: from flumine import BaseStrategy class ExampleStrategy ( BaseStrategy ): def start ( self ): # subscribe to streams print ( \"starting strategy 'ExampleStrategy'\" ) def check_market_book ( self , market , market_book ): # process_market_book only executed if this returns True if market_book . status != \"CLOSED\" : return True def process_market_book ( self , market , market_book ): # process marketBook object print ( market_book . status ) This strategy can now be initiated with the market and data filter before being added to the framework: from betfairlightweight.filters import ( streaming_market_filter , streaming_market_data_filter , ) strategy = ExampleStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ), market_data_filter = streaming_market_data_filter ( fields = [ \"EX_ALL_OFFERS\" ]) ) framework . add_strategy ( strategy ) The framework can now be started: framework . run () Order placement Orders can be placed as followed: from flumine.order.trade import Trade from flumine.order.order import LimitOrder class ExampleStrategy ( BaseStrategy ): def process_market_book ( self , market , market_book ): for runner in market_book . runners : if runner . selection_id == 123 : trade = Trade ( market_id = market_book . market_id , selection_id = runner . selection_id , handicap = runner . handicap , strategy = self ) order = trade . create_order ( side = \"LAY\" , order_type = LimitOrder ( price = 1.01 , size = 2.00 ) ) market . place_order ( order ) This order will be validated through controls, stored in the blotter and sent straight to the execution thread pool for execution. It is also possible to batch orders into transactions as follows: with market . transaction () as t : market . place_order ( order ) # executed immediately in separate transaction t . place_order ( order ) # executed on transaction __exit__ with market . transaction () as t : t . place_order ( order ) t . execute () # above order executed t . cancel_order ( order ) t . place_order ( order ) # both executed on transaction __exit__ Stream class By default the stream class will be a MarketStream which provides a MarketBook python object, if collecting data this can be changed to a DataStream class however process_raw_data will be called and not process_market_book: from flumine import BaseStrategy from flumine.streams.datastream import DataStream class ExampleDataStrategy ( BaseStrategy ): def process_raw_data ( self , publish_time , data ): print ( publish_time , data ) strategy = ExampleDataStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ), stream_class = DataStream ) flumine . add_strategy ( strategy ) The OrderDataStream class can be used to record order data as per market: from flumine.streams.datastream import OrderDataStream strategy = ExampleDataStrategy ( market_filter = None , stream_class = OrderDataStream ) flumine . add_strategy ( strategy ) Paper Trading Flumine can be used to paper trade strategies live using the following code: from flumine import clients client = clients . BetfairClient ( trading , paper_trade = True ) Market data will be recieved as per live but any orders will use Simulated execution and Simulated order polling to replicate live trading. Tip This can be handy when testing strategies as the betfair website can be used to validate the market. Simulation Flumine can be used to simulate strategies using the following code: from flumine import FlumineSimulation , clients client = clients . SimulatedClient () framework = FlumineSimulation ( client = client ) strategy = ExampleStrategy ( market_filter = { \"markets\" : [ \"/tmp/marketdata/1.170212754\" ]} ) framework . add_strategy ( strategy ) framework . run () Note the use of market filter to pass the file directories. Listener kwargs Sometimes a subset of the market lifetime is required, this can be optimised by limiting the number of updates to process resulting in faster simulation: strategy = ExampleStrategy ( market_filter = { \"markets\" : [ \"/tmp/marketdata/1.170212754\" ], \"listener_kwargs\" : { \"inplay\" : False , \"seconds_to_start\" : 600 }, } ) inplay: Filter inplay flag seconds_to_start: Filter market seconds to start calculate_market_tv: As per bflw listener arg cumulative_runner_tv: As per bflw listener arg The extra kwargs above will limit processing to preplay in the final 10 minutes. Tip Multiple strategies and markets can be passed, flumine will pass the MarketBooks to the correct strategy via its subscription. Event Processing It is also possible to process events with multiple markets such as win/place in racing or all football markets as per live by adding the following flag: strategy = ExampleStrategy ( market_filter = { \"markets\" : [ .. ], \"event_processing\" : True } ) The Market object contains a helper method for accessing other event linked markets: place_market = market . event [ \"PLACE\" ] Market Filter When simulating you can filter markets to be processed by using the market_type and country_code filter as per live: strategy = ExampleStrategy ( market_filter = { \"markets\" : [ .. ], \"market_types\" : [ \"MATCH_ODDS\" ], \"country_codes\" : [ \"GB\" ]} ) Simulation Simulation uses the SimulatedExecution execution class and tries to accurately simulate matching with the following: Place/Cancel/Replace latency delay added BetDelay added based on market state Queue positioning based on liquidity available Order lapse on market version change Order lapse and reduction on runner removal BSP Limitations #192: Queue cancellations Double counting of liquidity (active) Currency fluctuations","title":"QuickStart"},{"location":"quickstart/#quickstart","text":"","title":"QuickStart"},{"location":"quickstart/#live","text":"Tip flumine uses betfairlightweight for communicating with the Betfair API, please see docs for how to use/setup before proceeding. First, start by importing flumine/bflw and creating a trading and framework client: import betfairlightweight from flumine import Flumine , clients trading = betfairlightweight . APIClient ( \"username\" ) client = clients . BetfairClient ( trading ) framework = Flumine ( client = client ) Note flumine will handle login, logout and keep alive whilst the framework is running using the keep_alive worker. A strategy can now be created by using the BaseStrategy class: from flumine import BaseStrategy class ExampleStrategy ( BaseStrategy ): def start ( self ): # subscribe to streams print ( \"starting strategy 'ExampleStrategy'\" ) def check_market_book ( self , market , market_book ): # process_market_book only executed if this returns True if market_book . status != \"CLOSED\" : return True def process_market_book ( self , market , market_book ): # process marketBook object print ( market_book . status ) This strategy can now be initiated with the market and data filter before being added to the framework: from betfairlightweight.filters import ( streaming_market_filter , streaming_market_data_filter , ) strategy = ExampleStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ), market_data_filter = streaming_market_data_filter ( fields = [ \"EX_ALL_OFFERS\" ]) ) framework . add_strategy ( strategy ) The framework can now be started: framework . run ()","title":"Live"},{"location":"quickstart/#order-placement","text":"Orders can be placed as followed: from flumine.order.trade import Trade from flumine.order.order import LimitOrder class ExampleStrategy ( BaseStrategy ): def process_market_book ( self , market , market_book ): for runner in market_book . runners : if runner . selection_id == 123 : trade = Trade ( market_id = market_book . market_id , selection_id = runner . selection_id , handicap = runner . handicap , strategy = self ) order = trade . create_order ( side = \"LAY\" , order_type = LimitOrder ( price = 1.01 , size = 2.00 ) ) market . place_order ( order ) This order will be validated through controls, stored in the blotter and sent straight to the execution thread pool for execution. It is also possible to batch orders into transactions as follows: with market . transaction () as t : market . place_order ( order ) # executed immediately in separate transaction t . place_order ( order ) # executed on transaction __exit__ with market . transaction () as t : t . place_order ( order ) t . execute () # above order executed t . cancel_order ( order ) t . place_order ( order ) # both executed on transaction __exit__","title":"Order placement"},{"location":"quickstart/#stream-class","text":"By default the stream class will be a MarketStream which provides a MarketBook python object, if collecting data this can be changed to a DataStream class however process_raw_data will be called and not process_market_book: from flumine import BaseStrategy from flumine.streams.datastream import DataStream class ExampleDataStrategy ( BaseStrategy ): def process_raw_data ( self , publish_time , data ): print ( publish_time , data ) strategy = ExampleDataStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], country_codes = [ \"GB\" ], market_types = [ \"WIN\" ], ), stream_class = DataStream ) flumine . add_strategy ( strategy ) The OrderDataStream class can be used to record order data as per market: from flumine.streams.datastream import OrderDataStream strategy = ExampleDataStrategy ( market_filter = None , stream_class = OrderDataStream ) flumine . add_strategy ( strategy )","title":"Stream class"},{"location":"quickstart/#paper-trading","text":"Flumine can be used to paper trade strategies live using the following code: from flumine import clients client = clients . BetfairClient ( trading , paper_trade = True ) Market data will be recieved as per live but any orders will use Simulated execution and Simulated order polling to replicate live trading. Tip This can be handy when testing strategies as the betfair website can be used to validate the market.","title":"Paper Trading"},{"location":"quickstart/#simulation","text":"Flumine can be used to simulate strategies using the following code: from flumine import FlumineSimulation , clients client = clients . SimulatedClient () framework = FlumineSimulation ( client = client ) strategy = ExampleStrategy ( market_filter = { \"markets\" : [ \"/tmp/marketdata/1.170212754\" ]} ) framework . add_strategy ( strategy ) framework . run () Note the use of market filter to pass the file directories.","title":"Simulation"},{"location":"quickstart/#listener-kwargs","text":"Sometimes a subset of the market lifetime is required, this can be optimised by limiting the number of updates to process resulting in faster simulation: strategy = ExampleStrategy ( market_filter = { \"markets\" : [ \"/tmp/marketdata/1.170212754\" ], \"listener_kwargs\" : { \"inplay\" : False , \"seconds_to_start\" : 600 }, } ) inplay: Filter inplay flag seconds_to_start: Filter market seconds to start calculate_market_tv: As per bflw listener arg cumulative_runner_tv: As per bflw listener arg The extra kwargs above will limit processing to preplay in the final 10 minutes. Tip Multiple strategies and markets can be passed, flumine will pass the MarketBooks to the correct strategy via its subscription.","title":"Listener kwargs"},{"location":"quickstart/#event-processing","text":"It is also possible to process events with multiple markets such as win/place in racing or all football markets as per live by adding the following flag: strategy = ExampleStrategy ( market_filter = { \"markets\" : [ .. ], \"event_processing\" : True } ) The Market object contains a helper method for accessing other event linked markets: place_market = market . event [ \"PLACE\" ]","title":"Event Processing"},{"location":"quickstart/#market-filter","text":"When simulating you can filter markets to be processed by using the market_type and country_code filter as per live: strategy = ExampleStrategy ( market_filter = { \"markets\" : [ .. ], \"market_types\" : [ \"MATCH_ODDS\" ], \"country_codes\" : [ \"GB\" ]} )","title":"Market Filter"},{"location":"quickstart/#simulation_1","text":"Simulation uses the SimulatedExecution execution class and tries to accurately simulate matching with the following: Place/Cancel/Replace latency delay added BetDelay added based on market state Queue positioning based on liquidity available Order lapse on market version change Order lapse and reduction on runner removal BSP Limitations #192: Queue cancellations Double counting of liquidity (active) Currency fluctuations","title":"Simulation"},{"location":"sportsdata/","text":"Sports Data Flumine is able to connect to the sports-data-stream provided by Betfair for live data on cricket and races. Tip Your appKey must be authorised to access the sports-data stream, contact bdp@betfair.com Cricket Subscription A cricket subscription can be added via the sports_data_filter on a strategy strategy = ExampleStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"4\" ], market_types = [ \"MATCH_ODDS\" ] ), sports_data_filter = [ \"cricketSubscription\" ], ) Race Subscription A race subscription can be added via the sports_data_filter on a strategy strategy = ExampleStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], market_types = [ \"WIN\" ] ), sports_data_filter = [ \"raceSubscription\" ], ) Strategy Any sports data stream updates will be available in the strategy via the process_sports_data function class ExampleStrategy ( BaseStrategy ): def process_sports_data ( self , market : Market , sports_data : Union [ Race , CricketMatch ] ) -> None : # called on each update from sports-data-stream print ( market , sports_data ) Data Recorder The example marketrecorder.py can be modified to record race and cricket data by updating the process_raw_data with the matching op and data keys. marketSubscription mcm and mc orderSubscription ocm and oc cricketSubscription ccm and cc raceSubscription rcm and rc And using the correct stream class: Cricket Recorder from flumine.streams.datastream import CricketDataStream strategy = MarketRecorder ( market_filter = None , stream_class = CricketDataStream , context = { \"local_dir\" : \"/tmp\" , \"force_update\" : False , \"remove_file\" : True , \"remove_gz_file\" : False , }, ) Race Recorder from flumine.streams.datastream import RaceDataStream strategy = MarketRecorder ( market_filter = None , stream_class = RaceDataStream , context = { \"local_dir\" : \"/tmp\" , \"force_update\" : False , \"remove_file\" : True , \"remove_gz_file\" : False , }, )","title":"Sports Data"},{"location":"sportsdata/#sports-data","text":"Flumine is able to connect to the sports-data-stream provided by Betfair for live data on cricket and races. Tip Your appKey must be authorised to access the sports-data stream, contact bdp@betfair.com","title":"Sports Data"},{"location":"sportsdata/#cricket-subscription","text":"A cricket subscription can be added via the sports_data_filter on a strategy strategy = ExampleStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"4\" ], market_types = [ \"MATCH_ODDS\" ] ), sports_data_filter = [ \"cricketSubscription\" ], )","title":"Cricket Subscription"},{"location":"sportsdata/#race-subscription","text":"A race subscription can be added via the sports_data_filter on a strategy strategy = ExampleStrategy ( market_filter = streaming_market_filter ( event_type_ids = [ \"7\" ], market_types = [ \"WIN\" ] ), sports_data_filter = [ \"raceSubscription\" ], )","title":"Race Subscription"},{"location":"sportsdata/#strategy","text":"Any sports data stream updates will be available in the strategy via the process_sports_data function class ExampleStrategy ( BaseStrategy ): def process_sports_data ( self , market : Market , sports_data : Union [ Race , CricketMatch ] ) -> None : # called on each update from sports-data-stream print ( market , sports_data )","title":"Strategy"},{"location":"sportsdata/#data-recorder","text":"The example marketrecorder.py can be modified to record race and cricket data by updating the process_raw_data with the matching op and data keys. marketSubscription mcm and mc orderSubscription ocm and oc cricketSubscription ccm and cc raceSubscription rcm and rc And using the correct stream class:","title":"Data Recorder"},{"location":"sportsdata/#cricket-recorder","text":"from flumine.streams.datastream import CricketDataStream strategy = MarketRecorder ( market_filter = None , stream_class = CricketDataStream , context = { \"local_dir\" : \"/tmp\" , \"force_update\" : False , \"remove_file\" : True , \"remove_gz_file\" : False , }, )","title":"Cricket Recorder"},{"location":"sportsdata/#race-recorder","text":"from flumine.streams.datastream import RaceDataStream strategy = MarketRecorder ( market_filter = None , stream_class = RaceDataStream , context = { \"local_dir\" : \"/tmp\" , \"force_update\" : False , \"remove_file\" : True , \"remove_gz_file\" : False , }, )","title":"Race Recorder"},{"location":"strategies/","text":"Strategies BaseStrategy The base strategy class should be used for all strategies and contains the following parameters / functions for order/trade execution. Parameters market_filter Streaming market filter or list of filters required market_data_filter Streaming market data filter required streaming_timeout Streaming timeout, will call snap() on cache every x seconds conflate_ms Streaming conflate stream_class MarketStream or RawDataStream name Strategy name, if None will default to class name context Dictionary object where any extra data can be stored here such as triggers max_selection_exposure Max exposure per selection (including new order), note this does not handle reduction in exposure due to laying another runner max_order_exposure Max exposure per order clients flumine.clients max_trade_count Max total number of trades per runner max_live_trade_count Max live (with executable orders) trades per runner multi_order_trades Allow multiple live orders per trade Functions The following functions can be overridden dependent on the strategy: add() Function called when strategy is added to framework start() Function called when framework starts check_market_book() Function called with marketBook, process_market_book is only executed if this returns True process_market_book() Processes market book updates, called on every update that is received process_raw_data() As per process_market_book but handles raw data process_orders() Process list of Order objects for strategy and Market process_closed_market() Process Market after closure finish() Function called when framework ends Runner Context Each strategy stores a RunnerContext object which contains the state of a runner based on all and current active trades. This is used by controls to calculate exposure and control the number of live or total trades. runner_context = self . get_runner_context ( market . market_id , runner . selection_id , runner . handicap ) runner_context . live_trade_count","title":"Strategies"},{"location":"strategies/#strategies","text":"","title":"Strategies"},{"location":"strategies/#basestrategy","text":"The base strategy class should be used for all strategies and contains the following parameters / functions for order/trade execution.","title":"BaseStrategy"},{"location":"strategies/#parameters","text":"market_filter Streaming market filter or list of filters required market_data_filter Streaming market data filter required streaming_timeout Streaming timeout, will call snap() on cache every x seconds conflate_ms Streaming conflate stream_class MarketStream or RawDataStream name Strategy name, if None will default to class name context Dictionary object where any extra data can be stored here such as triggers max_selection_exposure Max exposure per selection (including new order), note this does not handle reduction in exposure due to laying another runner max_order_exposure Max exposure per order clients flumine.clients max_trade_count Max total number of trades per runner max_live_trade_count Max live (with executable orders) trades per runner multi_order_trades Allow multiple live orders per trade","title":"Parameters"},{"location":"strategies/#functions","text":"The following functions can be overridden dependent on the strategy: add() Function called when strategy is added to framework start() Function called when framework starts check_market_book() Function called with marketBook, process_market_book is only executed if this returns True process_market_book() Processes market book updates, called on every update that is received process_raw_data() As per process_market_book but handles raw data process_orders() Process list of Order objects for strategy and Market process_closed_market() Process Market after closure finish() Function called when framework ends","title":"Functions"},{"location":"strategies/#runner-context","text":"Each strategy stores a RunnerContext object which contains the state of a runner based on all and current active trades. This is used by controls to calculate exposure and control the number of live or total trades. runner_context = self . get_runner_context ( market . market_id , runner . selection_id , runner . handicap ) runner_context . live_trade_count","title":"Runner Context"},{"location":"trades/","text":"Trades / Orders Trade A trade object is used to handle order execution. from flumine.order.trade import Trade from flumine.order.ordertype import LimitOrder trade = Trade ( market_id = \"1.2345678\" , selection_id = 123456 , handicap = 1.0 , strategy = strategy ) trade . orders # [] trade . status # TradeStatus.LIVE order = trade . create_order ( side = \"LAY\" , order_type = LimitOrder ( price = 1.01 , size = 2.00 ) ) trade . orders # [<BetfairOrder>] Parameters market_id Market Id selection_id Selection Id handicap Runner handicap strategy Strategy object notes Trade notes, used to store market / trigger info for later analysis place_reset_seconds Seconds to wait since runner_context.reset before allowing another order reset_seconds Seconds to wait since runner_context.place before allowing another order custom You can create your own trade classes and then handle the logic within the strategy.process_orders function. Order Order objects store all order data locally allowing trade logic to be applied. from flumine.order.order import BetfairOrder , LimitOrder order = BetfairOrder ( trade = trade , side = \"LAY\" , order_type = LimitOrder ( price = 1.01 , size = 2.00 ) ) order . status # OrderStatus.PENDING order . executable () order . execution_complete ()","title":"Trades / Orders"},{"location":"trades/#trades-orders","text":"","title":"Trades / Orders"},{"location":"trades/#trade","text":"A trade object is used to handle order execution. from flumine.order.trade import Trade from flumine.order.ordertype import LimitOrder trade = Trade ( market_id = \"1.2345678\" , selection_id = 123456 , handicap = 1.0 , strategy = strategy ) trade . orders # [] trade . status # TradeStatus.LIVE order = trade . create_order ( side = \"LAY\" , order_type = LimitOrder ( price = 1.01 , size = 2.00 ) ) trade . orders # [<BetfairOrder>]","title":"Trade"},{"location":"trades/#parameters","text":"market_id Market Id selection_id Selection Id handicap Runner handicap strategy Strategy object notes Trade notes, used to store market / trigger info for later analysis place_reset_seconds Seconds to wait since runner_context.reset before allowing another order reset_seconds Seconds to wait since runner_context.place before allowing another order","title":"Parameters"},{"location":"trades/#custom","text":"You can create your own trade classes and then handle the logic within the strategy.process_orders function.","title":"custom"},{"location":"trades/#order","text":"Order objects store all order data locally allowing trade logic to be applied. from flumine.order.order import BetfairOrder , LimitOrder order = BetfairOrder ( trade = trade , side = \"LAY\" , order_type = LimitOrder ( price = 1.01 , size = 2.00 ) ) order . status # OrderStatus.PENDING order . executable () order . execution_complete ()","title":"Order"},{"location":"workers/","text":"Workers Background Workers Background workers run in their own thread allowing cleanup / cron like workers to run in the background, by default flumine adds the following workers: keep_alive : runs every 1200s (or session_timeout/2) to make sure clients are logged and kept alive poll_account_balance : runs every 120s to poll account balance endpoint poll_market_catalogue : runs every 60s to poll listMarketCatalogue endpoint poll_market_closure : checks for closed markets to get cleared orders at order and market level Variables flumine : Framework function : Function to be called interval : Interval in seconds, set to None for single call func_args : Function args func_kwargs : Function kwargs start_delay : Start delay in seconds context : Worker context name : Worker name Custom Workers Further workers can be added as per: from flumine.worker import BackgroundWorker def func ( context : dict , flumine , name = \"\" ): print ( name ) worker = BackgroundWorker ( framework , interval = 10 , function = func , func_args = ( \"hello\" ,) ) framework . add_worker ( worker )","title":"Workers"},{"location":"workers/#workers","text":"","title":"Workers"},{"location":"workers/#background-workers","text":"Background workers run in their own thread allowing cleanup / cron like workers to run in the background, by default flumine adds the following workers: keep_alive : runs every 1200s (or session_timeout/2) to make sure clients are logged and kept alive poll_account_balance : runs every 120s to poll account balance endpoint poll_market_catalogue : runs every 60s to poll listMarketCatalogue endpoint poll_market_closure : checks for closed markets to get cleared orders at order and market level","title":"Background Workers"},{"location":"workers/#variables","text":"flumine : Framework function : Function to be called interval : Interval in seconds, set to None for single call func_args : Function args func_kwargs : Function kwargs start_delay : Start delay in seconds context : Worker context name : Worker name","title":"Variables"},{"location":"workers/#custom-workers","text":"Further workers can be added as per: from flumine.worker import BackgroundWorker def func ( context : dict , flumine , name = \"\" ): print ( name ) worker = BackgroundWorker ( framework , interval = 10 , function = func , func_args = ( \"hello\" ,) ) framework . add_worker ( worker )","title":"Custom Workers"}]}